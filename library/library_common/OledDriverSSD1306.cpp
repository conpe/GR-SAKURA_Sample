/********************************************/
/*			OLED(SSD1306)表示				*/
/*					for RX63n @ CS+			*/
/*					Wrote by conpe_			*/
/*							2015/02/25		*/
/********************************************/

// 【更新予定】


#include "OledDriverSSD1306.h"
//#include <new>

//static char StrBuff[OLED_MAX_STRING+1];

OledDriverSSD1306::OledDriverSSD1306(void){

	_CurRow = 0;
	_CurCol = 0;
	
	DCBuff = NULL;
}

OledDriverSSD1306::~OledDriverSSD1306(void){
	if(NULL!=DCBuff) delete DCBuff;
	
}

/*********************
 OLED初期化
SPI対応
**********************/
int8_t OledDriverSSD1306::begin(spi_module SpiModule, spi_pin PinMosi, spi_pin PinRspck, spi_pin pinSsl, pins PinDC, void (*Callback)()){
	spi_pin PinMiso;
	
	// DC記憶バッファ
	if(NULL!=DCBuff) delete DCBuff;
	DCBuff = new RingBuffer<uint8_t>(OLED_DC_BUFFER_SIZE_DEFAULT);
		if(NULL==DCBuff) __heap_chk_fail();
	if(NULL==DCBuff) return -1;
	
	_CtrlMode = OLED_SPI;
	
	switch(SpiModule){
	case RSPI_SPI0:
		SPIn = &SPI0;
		PinMiso = MISOA_NONE;
		break;
	case RSPI_SPI1:
		SPIn = &SPI1;
		PinMiso = MISOB_NONE;
		break;
	}
	
	
	// set port DC
	_PinDC = PinDC;
	setPinMode(PinDC, PIN_OUTPUT);
	setDC(OLED_WRITE_COMMAND);	// set to command transmit (wait for transmit end)
	lastDC = OLED_WRITE_COMMAND;
	
	// SSL(CS:chip select) setting
	switch(SpiModule){
	case RSPI_SPI0:
		if(pinSsl==SSLA_NONE){
			// 
		}else if(pinSsl<SSLA1_NONE){
			_SpiCs = RSPI_SSL0;
		}else if(pinSsl<SSLA2_NONE){
			_SpiCs = RSPI_SSL1;
		}else if(pinSsl<SSLA3_NONE){
			_SpiCs = RSPI_SSL2;
		}else{
			_SpiCs = RSPI_SSL3;
		}
		break;
	case RSPI_SPI1:
		if(pinSsl==SSLB_NONE){
			// 
		}else if(pinSsl<SSLB1_NONE){
			_SpiCs = RSPI_SSL0;
		}else if(pinSsl<SSLB2_NONE){
			_SpiCs = RSPI_SSL1;
		}else if(pinSsl<SSLB3_NONE){
			_SpiCs = RSPI_SSL2;
		}else{
			_SpiCs = RSPI_SSL3;
		}
		break;
	}
	
	
	
	// SPI open
	SPIn->begin(PinMosi, PinMiso, PinRspck, pinSsl, OLED_BUFFER_SIZE_DEFAULT);
	
	// コールバック関数登録
	SPIn->setCallBackFuncTx(Callback);
	
	// ディスプレイ初期化
	offDisplay();		// display   off
	initRegister();		// レジスタ初期化
	clearDisplay();		// ディスプレイ全消し
	setCur(0, 0);		// カーソル初期位置
	onDisplay();		//   display   on 
	
	return 0;
}


/*********************
 OLEDのレジスタセット
**********************/
void OledDriverSSD1306::initRegister(){
	


	writeCommand(0x00);  //   set  lower  column  address   
	writeCommand(0x10); //   set  higher  column  address   
	writeCommand(0xb0);  //   set page start  address  

	writeCommand(0x40);  //   set    display  start  line   
	  

	writeCommand(0x81);  //   set    contrast  control  
	writeCommand(0xCF);  

	writeCommand(0xa1);  //   set    remap 		// column address 127 is mapped to SEG0
	//writeCommand(0xa0);							// column address 0 is mapped to SEG0

	writeCommand(0xa6);  //   set    normal/inverse  display  

	writeCommand(0xa8);  //   set    multiplex  radio  
	writeCommand(0x3f);  // 

	writeCommand(0xad);  //   set    master    configuration  
	writeCommand(0x8e);  

	writeCommand(0xc8);  //  set com scan direction com[n-1]  to com0 
	//writeCommand(0xc0);  //  set com scan direction com[n-1]  to com0 
					// LSBかMSBか。
					
	writeCommand(0xd5);   // set display clock divide ratio/oscillator fruquency
	writeCommand(0x30); 

	writeCommand(0xd3);   // set display offset
	writeCommand(0x00);  // 

	writeCommand(0xda);   // set com  pin  configuration  
	writeCommand(0x12); 
	
	writeCommand(0x20);	// Set Addressing Mode. 
	writeCommand(0x00);	// Set Horizontal Addressing Mode. 右まで行ったら次の行
	
	writeCommand(0xb0);	// Set Page 0
	
	writeCommand(0x8d);	// interal dc-dc 
	writeCommand(0x14);	// Enable DC_DC 

	//writeCommand(0xaf);  //   display   on  
	
	
	//clearDisplay();
	//setCur(0, 0);
}



/*********************
 コマンド送信
バッファあくまで待つので注意
**********************/
int8_t OledDriverSSD1306::writeCommand(uint8_t Command){
	
	//while(DCBuff->isFull());	// 止まることあるっぽいのでやめ。
	
	if(!DCBuff->isFull()){	// 書けるなら
		DCBuff->add((uint8_t)OLED_WRITE_COMMAND);	// DC覚えておく
		write(Command);
		return 0;
	}
	
	return -1;
}

/*********************
 画面データ送信
バッファあくまで待つので注意
**********************/
int8_t OledDriverSSD1306::writeData(uint8_t Data){
	
	//while(DCBuff->isFull());	// 止まることあるっぽいのでやめ。
	
	if(!DCBuff->isFull()){	// 書けるなら
		DCBuff->add((uint8_t)OLED_WRITE_DATA);
		write(Data);
		// カーソル位置更新
		incCur();
		
		return 0;
	}
	
	return -1;
}


/*********************
 送信データセット
RSPIクラスのバッファにデータ送る
**********************/
int8_t OledDriverSSD1306::write(uint8_t Data){
	
	
	switch(_CtrlMode){
	case OLED_SPI:
		SPIn->setCS(_SpiCs);		// chip select pin ここでやるのはおかしいよねーバッファに溜まってる間にSSL変わっちゃ困るよねー
		
		return SPIn->transmit(Data);	// transmit
		
		//while(SPIn->transmit(Data));	// transmit. 成功するまで繰り返し
		//return 0;
	}
	
	return -1;
}

/*********************
 CD出力
**********************/
void OledDriverSSD1306::setDC(write_mode WriteMode){
	//while( !SPIn->isIdle() || !SPIn->isTxBuffEmpty());	// SPIモジュールがアイドルでないか、送信バッファに送信待ちが残ってるなら待つ。
	
	outPin(_PinDC, WriteMode);
	
	_DC = WriteMode;
	
}

/*********************
 画面クリア
バッファに出し終わるまで待つので注意
**********************/
void OledDriverSSD1306::clearDisplay(void){
	for(uint16_t kkk=0; kkk<0x400; kkk++){
		if(writeData(0x00)) break;
	}
}

/*********************
 1行クリア
バッファに出し終わるまで待つので注意
**********************/
void OledDriverSSD1306::clearLine(void){
	uint8_t CurRow = _CurRow;
	uint8_t CurCol = _CurCol;
	
	setCur(CurRow, 0);		// その行の先頭へ
	
	for(uint16_t kkk=0; kkk<OLED_WIDTH; kkk++){
		if(writeData(0x00)) break;
	}
	setCur(CurRow, CurCol);		// 元の場所へ
}


void OledDriverSSD1306::incCur(void){
	
	if(_CurCol<(OLED_WIDTH-1)){
		_CurCol++;
	}else{
		_CurCol = 0;
		if(_CurRow<(OLED_LINE-1)){
			_CurRow++;
		}else{
			_CurRow = 0;
		}
	}
	
}

void OledDriverSSD1306::setCur(uint8_t R, uint8_t C){
	if((R<OLED_LINE)&&(C<OLED_WIDTH)){
		writeCommand(0x00 | (C&0x07));  //   set  lower  column  address   
		writeCommand(0x10 | ((C>>3)&0x07)); //   set  higter  column  address   
		writeCommand(0xb0 | R);  //   set page start  address  
		
		_CurRow = R;
		_CurCol = C;
	}
}

void OledDriverSSD1306::setCurNextLine(void){	// Line Feed
	uint8_t CurRow = _CurRow;
	
	CurRow++;
	
	if(CurRow>=OLED_LINE){
		CurRow = 0;
	}
	
	setCur(CurRow, 0);
	
}

void OledDriverSSD1306::setCurNextCol(void){	// 次の列へ。右まで行ったら次の行。
	uint8_t CurCol = _CurCol;
	uint8_t CurRow = _CurRow;
	
	CurCol++;
	
	if(CurCol>=OLED_WIDTH){
		CurCol = 0;
		CurRow++;
		if(CurRow>=OLED_LINE){
			CurRow = 0;
		}
	}
	
	setCur(CurRow, CurCol);
	
}

/*********************
 指定行へ移動＆クリア
概要：
 指定した行へカーソルを移動し、その行の内容をクリアする
引数：
 Row 移動先の行(ライン)
**********************/
void OledDriverSSD1306::setCurNewLine(uint8_t Row){
	setCur(Row,0);
	clearLine();
}
/*********************
 指定場所へ移動＆クリア
概要：
 指定した場所へカーソルを移動し、その行の内容をクリアする
引数：
 Row 移動先の行(ライン)
 Col 移動先の列(ピクセル)
**********************/
void OledDriverSSD1306::setCurNewLine(uint8_t Row, uint8_t Col){
	setCur(Row,Col);
	clearLine();
}
	
	
int8_t OledDriverSSD1306::writeChar(char ch){
	uint8_t i;
	
	if('\r' == ch){
		return 0;	
	}
	
	// check clearance
	if((OLED_WIDTH-_CurCol)<5){	// その行の終わり5列以内だったら次の行にする
		setCurNextLine();	// 次の行へ
	}
	
	// transmit font
	if(ch<OLED_FONT_NUM){
		for(i = 0; i<5; i++){
			if(writeData(Font7h5w[ch-0x20][i])){
				return -1;
			}
		}
	}else{
		for(i = 0; i<5; i++){
			if(writeData(0x00)){
				return -1;
			}
		}
	}
	writeData(0x00);
	
	return 0;
}

int8_t OledDriverSSD1306::print(char ch){
	if(ch=='\n'){
		setCurNextLine();
		return 0;
		
	}else{
		return writeChar(ch);
	}
	
	return 0;
}


int8_t OledDriverSSD1306::print(int num){
	int16_t Cnt;
	int16_t Num;
	
	//char *pStr = new(StrBuff) char[OLED_MAX_STRING];
	//char *pStr = new char[OLED_MAX_STRING];
	char StrBuff[OLED_MAX_STRING];
	char *pStr = StrBuff;
	if(NULL==pStr){		// 確保できなければそのまま出しちゃう
		return -1;	
	}
	
	Num = sprintf(pStr, "%d", num);
	
	for(Cnt=0; Cnt<Num; Cnt++){
		writeChar(*pStr++);
	}
	
	//delete[] pStr;
	return 0;
}
	
int8_t OledDriverSSD1306::print(const char *control, ...){
	int16_t Cnt;
	int16_t Num;
	
	//char *pStr = new(StrBuff) char[OLED_MAX_STRING];
	//char *pStr = new char[OLED_MAX_STRING];
	char StrBuff[OLED_MAX_STRING];
	char *pStr = StrBuff;
	
	if(NULL==pStr){		// 確保できなければそのまま出しちゃう
		pStr = (char *)control;	
		Num = strlen(control);
	}else{
		va_list arg;
		va_start(arg, control);
		Num = vsprintf(pStr, control, arg);
		va_end(arg);
	}
	for(Cnt=0; Cnt<Num; Cnt++){
		if(*pStr=='\n'){
			setCurNextLine();
			pStr++;
		}else{
			writeChar(*pStr++);
		}
	}
	
	//delete[] pStr;
	return 0;
}

int8_t OledDriverSSD1306::println(const char *control, ...){
	int16_t Cnt;
	int16_t Num;
	
	//char *pStr = new(StrBuff) char[OLED_MAX_STRING];
	//char *pStr = new char[OLED_MAX_STRING];
	char StrBuff[OLED_MAX_STRING];
	char *pStr = StrBuff;
	
	if(NULL==pStr){		// 確保できなければそのまま出しちゃう
		pStr = (char *)control;	
		Num = strlen(control);
	}else{
		va_list arg;
		va_start(arg, control);
		Num = vsprintf(pStr, control, arg);
		va_end(arg);
	}
	
	for(Cnt=0; Cnt<Num; Cnt++){
		if(*pStr=='\n'){
			setCurNextLine();
			pStr++;
		}else{
			writeChar(*pStr++);
		}
	}
	setCurNextLine();
	
	//delete[] pStr;
	return 0;
}




/*********************
 文字データ
**********************/
const uint8_t OledDriverSSD1306::Font7h5w[192][5] = 
	{
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x20 ' '
	{ 0x00, 0x00, 0x4F, 0x00, 0x00 },	// 0x21 !
	{ 0x00, 0x07, 0x00, 0x07, 0x00 },	// 0x22 "
	{ 0x14, 0x7F, 0x14, 0x7F, 0x14 },	// 0x23 #
	{ 0x24, 0x2A, 0x7F, 0x2A, 0x12 },	// 0x24 $
	{ 0x23, 0x13, 0x08, 0x64, 0x62 },	// 0x25 %
	{ 0x36, 0x49, 0x55, 0x22, 0x50 },	// 0x26 &
	{ 0x00, 0x05, 0x03, 0x00, 0x00 },	// 0x27 '
	{ 0x00, 0x1C, 0x22, 0x41, 0x00 },	// 0x28 (
	{ 0x00, 0x41, 0x22, 0x1C, 0x00 },	// 0x29 )
	{ 0x14, 0x08, 0x3E, 0x08, 0x14 },	// 0x2A *
	{ 0x08, 0x08, 0x3E, 0x08, 0x08 },	// 0x2B +
	{ 0x00, 0x50, 0x30, 0x00, 0x00 },	// 0x2C ,
	{ 0x08, 0x08, 0x08, 0x08, 0x08 },	// 0x2D -
	{ 0x00, 0x60, 0x60, 0x00, 0x00 },	// 0x2E .
	{ 0x20, 0x10, 0x08, 0x04, 0x02 },	// 0x2F /
	{ 0x3E, 0x51, 0x49, 0x45, 0x3E },	// 0x30 0
	{ 0x00, 0x42, 0x7F, 0x40, 0x00 },	// 0x31 1
	{ 0x42, 0x61, 0x51, 0x49, 0x46 },	// 0x32 2
	{ 0x21, 0x41, 0x45, 0x4B, 0x31 },	// 0x33 3
	{ 0x18, 0x14, 0x12, 0x7F, 0x10 },	// 0x34 4
	{ 0x27, 0x45, 0x45, 0x45, 0x39 },	// 0x35 5
	{ 0x3C, 0x4A, 0x49, 0x49, 0x30 },	// 0x36 6
	{ 0x03, 0x01, 0x71, 0x09, 0x07 },	// 0x37 7
	{ 0x36, 0x49, 0x49, 0x49, 0x36 },	// 0x38 8
	{ 0x06, 0x49, 0x49, 0x29, 0x1E },	// 0x39 9
	{ 0x00, 0x36, 0x36, 0x00, 0x00 },	// 0x3A :
	{ 0x00, 0x56, 0x36, 0x00, 0x00 },	// 0x3B ;
	{ 0x08, 0x14, 0x22, 0x41, 0x00 },	// 0x3C <
	{ 0x14, 0x14, 0x14, 0x14, 0x14 },	// 0x3D =
	{ 0x00, 0x41, 0x22, 0x14, 0x08 },	// 0x3E >
	{ 0x02, 0x01, 0x51, 0x09, 0x06 },	// 0x3F ?
	{ 0x32, 0x49, 0x79, 0x41, 0x3E },	// 0x40 @
	{ 0x7E, 0x11, 0x11, 0x11, 0x7E },	// 0x41 A
	{ 0x7F, 0x49, 0x49, 0x49, 0x36 },	// 0x42 B
	{ 0x3E, 0x41, 0x41, 0x41, 0x22 },	// 0x43 C
	{ 0x7F, 0x41, 0x41, 0x22, 0x1C },	// 0x44 D
	{ 0x7F, 0x49, 0x49, 0x49, 0x41 },	// 0x45 E
	{ 0x7F, 0x09, 0x09, 0x09, 0x01 },	// 0x46 F
	{ 0x3E, 0x41, 0x49, 0x49, 0x7A },	// 0x47 G
	{ 0x7F, 0x08, 0x08, 0x08, 0x7F },	// 0x48 H
	{ 0x00, 0x41, 0x7F, 0x41, 0x00 },	// 0x49 I
	{ 0x20, 0x40, 0x41, 0x3F, 0x01 },	// 0x4A J
	{ 0x7F, 0x08, 0x14, 0x22, 0x41 },	// 0x4B K
	{ 0x7F, 0x40, 0x40, 0x40, 0x40 },	// 0x4C L
	{ 0x7F, 0x02, 0x0C, 0x02, 0x7F },	// 0x4D M
	{ 0x7F, 0x04, 0x08, 0x10, 0x7F },	// 0x4E N
	{ 0x3E, 0x41, 0x41, 0x41, 0x3E },	// 0x4F O
	{ 0x7F, 0x09, 0x09, 0x09, 0x06 },	// 0x50 P
	{ 0x3E, 0x41, 0x51, 0x21, 0x5E },	// 0x51 Q
	{ 0x7F, 0x09, 0x19, 0x29, 0x46 },	// 0x52 R
	{ 0x46, 0x49, 0x49, 0x49, 0x31 },	// 0x53 S
	{ 0x01, 0x01, 0x7F, 0x01, 0x01 },	// 0x54 T
	{ 0x3F, 0x40, 0x40, 0x40, 0x3F },	// 0x55 U
	{ 0x1F, 0x20, 0x40, 0x20, 0x1F },	// 0x56 V
	{ 0x3F, 0x40, 0x38, 0x40, 0x3F },	// 0x57 W
	{ 0x63, 0x14, 0x08, 0x14, 0x63 },	// 0x58 X
	{ 0x07, 0x08, 0x70, 0x08, 0x07 },	// 0x59 Y
	{ 0x61, 0x51, 0x49, 0x45, 0x43 },	// 0x5A Z
	{ 0x7F, 0x41, 0x41, 0x00, 0x00 },	// 0x5B [
	{ 0x15, 0x16, 0x7C, 0x16, 0x15 },	// 0x5C '\'
	{ 0x00, 0x41, 0x41, 0x7F, 0x00 },	// 0x5D ]
	{ 0x04, 0x02, 0x01, 0x02, 0x04 },	// 0x5E ^
	{ 0x40, 0x40, 0x40, 0x40, 0x40 },	// 0x5F _
	{ 0x00, 0x01, 0x02, 0x04, 0x00 },	// 0x60 `
	{ 0x20, 0x54, 0x54, 0x54, 0x78 },	// 0x61 a
	{ 0x7F, 0x48, 0x44, 0x44, 0x38 },	// 0x62 b
	{ 0x38, 0x44, 0x44, 0x44, 0x20 },	// 0x63 c
	{ 0x38, 0x44, 0x44, 0x48, 0x7F },	// 0x64 d
	{ 0x38, 0x54, 0x54, 0x54, 0x18 },	// 0x65 e
	{ 0x08, 0x7E, 0x09, 0x01, 0x02 },	// 0x66 f
	{ 0x0C, 0x52, 0x52, 0x52, 0x3E },	// 0x67 g
	{ 0x7F, 0x08, 0x04, 0x04, 0x78 },	// 0x68 h
	{ 0x00, 0x44, 0x7D, 0x40, 0x00 },	// 0x69 i
	{ 0x20, 0x40, 0x44, 0x3D, 0x00 },	// 0x6A j
	{ 0x7F, 0x10, 0x28, 0x44, 0x00 },	// 0x6B k
	{ 0x00, 0x41, 0x7F, 0x40, 0x00 },	// 0x6C l
	{ 0x7C, 0x04, 0x18, 0x04, 0x78 },	// 0x6D m
	{ 0x7C, 0x08, 0x04, 0x04, 0x78 },	// 0x6E n
	{ 0x38, 0x44, 0x44, 0x44, 0x38 },	// 0x6F o
	{ 0x7C, 0x14, 0x14, 0x14, 0x08 },	// 0x70 p
	{ 0x08, 0x14, 0x14, 0x18, 0x7C },	// 0x71 q
	{ 0x7C, 0x08, 0x04, 0x04, 0x08 },	// 0x72 r
	{ 0x48, 0x54, 0x54, 0x54, 0x20 },	// 0x73 s
	{ 0x04, 0x3F, 0x44, 0x40, 0x20 },	// 0x74 t
	{ 0x3C, 0x40, 0x40, 0x20, 0x7C },	// 0x75 u
	{ 0x1C, 0x20, 0x40, 0x20, 0x1C },	// 0x76 v
	{ 0x3C, 0x40, 0x38, 0x40, 0x3C },	// 0x77 w
	{ 0x44, 0x28, 0x10, 0x28, 0x44 },	// 0x78 x
	{ 0x0C, 0x50, 0x50, 0x50, 0x3C },	// 0x79 y
	{ 0x44, 0x64, 0x54, 0x4C, 0x44 },	// 0x7A z
	{ 0x00, 0x08, 0x36, 0x41, 0x00 },	// 0x7B {
	{ 0x00, 0x00, 0x7F, 0x00, 0x00 },	// 0x7C |
	{ 0x00, 0x41, 0x36, 0x08, 0x00 },	// 0x7D }
	{ 0x08, 0x08, 0x2A, 0x1C, 0x08 },	// 0x7E '->'
	{ 0x08, 0x1C, 0x2A, 0x08, 0x08 },	// 0x7F '<-'
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x80 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x81 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x82 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x83 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x84 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x85 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x86 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x87 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x88 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x89 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8A 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8B 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8C 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8D 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8E 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x8F 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x90 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x91 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x92 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x93 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x94 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x95 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x96 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x97 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x98 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x99 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9A 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9B 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9C 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9D 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9E 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0x9F 
	{ 0x00, 0x00, 0x00, 0x00, 0x00 },	// 0xA0 
	{ 0x70, 0x50, 0x70, 0x00, 0x00 },	// 0xA1 ｡
	{ 0x00, 0x00, 0x0F, 0x01, 0x01 },	// 0xA2 ｢
	{ 0x40, 0x40, 0x78, 0x00, 0x00 },	// 0xA3 ｣
	{ 0x10, 0x20, 0x40, 0x00, 0x00 },	// 0xA4 ､
	{ 0x00, 0x18, 0x18, 0x00, 0x00 },	// 0xA5 ･
	{ 0x0A, 0x0A, 0x4A, 0x2A, 0x1E },	// 0xA6 ｦ
	{ 0x04, 0x44, 0x34, 0x14, 0x0C },	// 0xA7 ｧ
	{ 0x20, 0x10, 0x78, 0x04, 0x00 },	// 0xA8 ｨ
	{ 0x18, 0x08, 0x4C, 0x48, 0x38 },	// 0xA9 ｩ
	{ 0x44, 0x44, 0x7C, 0x44, 0x44 },	// 0xAA ｪ
	{ 0x48, 0x28, 0x18, 0x7C, 0x08 },	// 0xAB ｫ
	{ 0x08, 0x7C, 0x08, 0x28, 0x18 },	// 0xAC ｬ
	{ 0x40, 0x48, 0x48, 0x78, 0x40 },	// 0xAD ｭ
	{ 0x54, 0x54, 0x54, 0x7C, 0x00 },	// 0xAE ｮ
	{ 0x18, 0x00, 0x58, 0x40, 0x38 },	// 0xAF ｯ
	{ 0x08, 0x08, 0x08, 0x08, 0x08 },	// 0xB0 ｰ
	{ 0x01, 0x41, 0x3D, 0x09, 0x07 },	// 0xB1 ｱ
	{ 0x10, 0x08, 0x7C, 0x02, 0x01 },	// 0xB2 ｲ
	{ 0x0E, 0x02, 0x43, 0x22, 0x1E },	// 0xB3 ｳ
	{ 0x42, 0x42, 0x7E, 0x42, 0x42 },	// 0xB4 ｴ
	{ 0x22, 0x12, 0x0A, 0x7F, 0x02 },	// 0xB5 ｵ
	{ 0x42, 0x3F, 0x02, 0x42, 0x3E },	// 0xB6 ｶ
	{ 0x0A, 0x0A, 0x7F, 0x0A, 0x0A },	// 0xB7 ｷ
	{ 0x08, 0x46, 0x42, 0x22, 0x1E },	// 0xB8 ｸ
	{ 0x04, 0x03, 0x42, 0x3E, 0x02 },	// 0xB9 ｹ
	{ 0x42, 0x42, 0x42, 0x42, 0x7E },	// 0xBA ｺ
	{ 0x02, 0x4F, 0x22, 0x1F, 0x02 },	// 0xBB ｻ
	{ 0x4A, 0x4A, 0x40, 0x20, 0x1C },	// 0xBC ｼ
	{ 0x42, 0x22, 0x12, 0x2A, 0x46 },	// 0xBD ｽ
	{ 0x02, 0x3F, 0x42, 0x4A, 0x46 },	// 0xBE ｾ
	{ 0x06, 0x48, 0x40, 0x20, 0x1E },	// 0xBF ｿ
	{ 0x08, 0x46, 0x4A, 0x32, 0x1E },	// 0xC0 ﾀ
	{ 0x0A, 0x4A, 0x3E, 0x09, 0x08 },	// 0xC1 ﾁ
	{ 0x0E, 0x00, 0x4E, 0x20, 0x1E },	// 0xC2 ﾂ
	{ 0x04, 0x45, 0x3D, 0x05, 0x04 },	// 0xC3 ﾃ
	{ 0x00, 0x7F, 0x08, 0x10, 0x00 },	// 0xC4 ﾄ
	{ 0x44, 0x24, 0x1F, 0x04, 0x04 },	// 0xC5 ﾅ
	{ 0x40, 0x42, 0x42, 0x42, 0x40 },	// 0xC6 ﾆ
	{ 0x42, 0x2A, 0x12, 0x2A, 0x06 },	// 0xC7 ﾇ
	{ 0x22, 0x12, 0x7B, 0x16, 0x22 },	// 0xC8 ﾈ
	{ 0x00, 0x40, 0x20, 0x1F, 0x00 },	// 0xC9 ﾉ
	{ 0x78, 0x00, 0x02, 0x04, 0x78 },	// 0xCA ﾊ
	{ 0x3F, 0x44, 0x44, 0x44, 0x44 },	// 0xCB ﾋ
	{ 0x02, 0x42, 0x42, 0x22, 0x1E },	// 0xCC ﾌ
	{ 0x04, 0x02, 0x04, 0x08, 0x30 },	// 0xCD ﾍ
	{ 0x32, 0x02, 0x7F, 0x02, 0x32 },	// 0xCE ﾎ
	{ 0x02, 0x12, 0x22, 0x52, 0x0E },	// 0xCF ﾏ
	{ 0x00, 0x2A, 0x2A, 0x2A, 0x40 },	// 0xD0 ﾐ
	{ 0x38, 0x24, 0x22, 0x20, 0x70 },	// 0xD1 ﾑ
	{ 0x40, 0x28, 0x10, 0x28, 0x06 },	// 0xD2 ﾒ
	{ 0x0A, 0x3E, 0x4A, 0x4A, 0x4A },	// 0xD3 ﾓ
	{ 0x04, 0x7F, 0x04, 0x14, 0x0C },	// 0xD4 ﾔ
	{ 0x40, 0x42, 0x42, 0x7E, 0x40 },	// 0xD5 ﾕ
	{ 0x4A, 0x4A, 0x4A, 0x4A, 0x7E },	// 0xD6 ﾖ
	{ 0x04, 0x05, 0x45, 0x25, 0x1C },	// 0xD7 ﾗ
	{ 0x0F, 0x40, 0x20, 0x1F, 0x00 },	// 0xD8 ﾘ
	{ 0x7C, 0x00, 0x7E, 0x40, 0x30 },	// 0xD9 ﾙ
	{ 0x7E, 0x40, 0x20, 0x10, 0x08 },	// 0xDA ﾚ
	{ 0x7E, 0x42, 0x42, 0x42, 0x7E },	// 0xDB ﾛ
	{ 0x0E, 0x02, 0x42, 0x22, 0x1E },	// 0xDC ﾜ
	{ 0x42, 0x42, 0x40, 0x20, 0x18 },	// 0xDD ﾝ
	{ 0x02, 0x04, 0x01, 0x02, 0x00 },	// 0xDE ﾞ
	{ 0x07, 0x05, 0x07, 0x00, 0x00 }	// 0xDF ﾟ
};	//HD44780 Character Patterns (ROM Code:A00) Shift-JIS



/*********************
 SPI送信割り込みコールバック関数
 送信データに合わせてDCを出力する
**********************/
void OledDriverSSD1306::callbackTxIsr(void){
	static bool_t TrasmitLast = 0;
	write_mode DC = OLED_WRITE_DATA;
	
	if(TrasmitLast){	// 前回送信したので今回それに対応するCDをセットする
		DCBuff->read((uint8_t *)&DC);
		setDC(DC);
	}
	
	TrasmitLast = !SPIn->isTxBuffEmpty();	// SPI送信処理時に送信した。-> 次割り込み時にCD変化させる
	
}
	
	
	
	
	
	